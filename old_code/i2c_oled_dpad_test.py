font5x7 = {
    ' ': [0x00, 0x00, 0x00, 0x00, 0x00],  # Space
    '!': [0x00, 0x00, 0x1F, 0x00, 0x00],  # !
    '"': [0x00, 0x03, 0x00, 0x03, 0x00],  # "
    '#': [0x0A, 0x1F, 0x0A, 0x1F, 0x0A],  # #
    '$': [0x12, 0x15, 0x1F, 0x15, 0x09],  # $
    '%': [0x19, 0x1D, 0x06, 0x13, 0x13],  # %
    '&': [0x0A, 0x15, 0x1A, 0x10, 0x0A],  # &
    '\'': [0x00, 0x03, 0x00, 0x00, 0x00],  # '
    '(': [0x00, 0x0E, 0x11, 0x00, 0x00],  # (
    ')': [0x00, 0x00, 0x11, 0x0E, 0x00],  # )
    '*': [0x05, 0x02, 0x0F, 0x02, 0x05],  # *
    '+': [0x04, 0x04, 0x1F, 0x04, 0x04],  # +
    ',': [0x00, 0x10, 0x08, 0x00, 0x00],  # ,
    '-': [0x04, 0x04, 0x04, 0x04, 0x04],  # -
    '.': [0x00, 0x10, 0x00, 0x00, 0x00],  # .
    '/': [0x10, 0x0C, 0x03, 0x00, 0x00],  # /
    ':': [0x00, 0x00, 0x0A, 0x00, 0x00],  # :
    ';': [0x00, 0x10, 0x0A, 0x00, 0x00],  # ;
    '<': [0x04, 0x0A, 0x11, 0x00, 0x00],  # <
    '=': [0x0A, 0x0A, 0x0A, 0x0A, 0x00],  # =
    '>': [0x11, 0x0A, 0x04, 0x00, 0x00],  # >
    '?': [0x02, 0x01, 0x15, 0x05, 0x02],  # ?
    '@': [0x0E, 0x15, 0x15, 0x05, 0x02],  # @
    
    '[': [0x00, 0x1F, 0x11, 0x00, 0x00],  # [
    '\\': [0x00, 0x03, 0x0C, 0x10, 0x00], # \
    ']': [0x00, 0x00, 0x11, 0x1F, 0x00],  # ]
    '^': [0x04, 0x02, 0x01, 0x02, 0x04],  # ^
    '_': [0x10, 0x10, 0x10, 0x10, 0x10],  # _
    '`': [0x01, 0x02, 0x00, 0x00, 0x00],  # `


    '0': [0x0E, 0x11, 0x11, 0x11, 0x0E],  # 0
    '1': [0x00, 0x12, 0x1F, 0x10, 0x00],  # 1
    '2': [0x12, 0x19, 0x15, 0x12, 0x00],  # 2
    '3': [0x11, 0x15, 0x15, 0x1F, 0x00],  # 3
    '4': [0x07, 0x04, 0x04, 0x1F, 0x04],  # 4
    '5': [0x17, 0x15, 0x15, 0x15, 0x09],  # 5
    '6': [0x0E, 0x15, 0x15, 0x15, 0x08],  # 6
    '7': [0x01, 0x01, 0x1D, 0x07, 0x01],  # 7
    '8': [0x0A, 0x15, 0x15, 0x15, 0x0A],  # 8
    '9': [0x02, 0x15, 0x15, 0x15, 0x0E],  # 9

    'A': [0x1E, 0x05, 0x05, 0x05, 0x1E],  # A
    'B': [0x1F, 0x15, 0x15, 0x15, 0x0A],  # B
    'C': [0x0E, 0x11, 0x11, 0x11, 0x0A],  # C
    'D': [0x1F, 0x11, 0x11, 0x11, 0x0E],  # D
    'E': [0x1F, 0x15, 0x15, 0x15, 0x11],  # E
    'F': [0x1F, 0x05, 0x05, 0x05, 0x01],  # F
    'G': [0x0E, 0x11, 0x15, 0x15, 0x0D],  # G
    'H': [0x1F, 0x04, 0x04, 0x04, 0x1F],  # H
    'I': [0x00, 0x11, 0x1F, 0x11, 0x00],  # I
    'J': [0x08, 0x10, 0x11, 0x11, 0x0F],  # J
    'K': [0x1F, 0x04, 0x0A, 0x11, 0x00],  # K
    'L': [0x1F, 0x10, 0x10, 0x10, 0x00],  # L
    'M': [0x1F, 0x02, 0x04, 0x02, 0x1F],  # M
    'N': [0x1F, 0x02, 0x04, 0x08, 0x1F],  # N
    'O': [0x0E, 0x11, 0x11, 0x11, 0x0E],  # O
    'P': [0x1F, 0x05, 0x05, 0x05, 0x02],  # P
    'Q': [0x0E, 0x11, 0x19, 0x11, 0x1E],  # Q
    'R': [0x1F, 0x05, 0x0D, 0x15, 0x12],  # R
    'S': [0x12, 0x15, 0x15, 0x15, 0x09],  # S
    'T': [0x01, 0x01, 0x1F, 0x01, 0x01],  # T
    'U': [0x0F, 0x10, 0x10, 0x10, 0x0F],  # U
    'V': [0x07, 0x08, 0x10, 0x08, 0x07],  # V
    'W': [0x0F, 0x10, 0x08, 0x10, 0x0F],  # W
    'X': [0x11, 0x0A, 0x04, 0x0A, 0x11],  # X
    'Y': [0x01, 0x02, 0x1C, 0x02, 0x01],  # Y
    'Z': [0x11, 0x19, 0x15, 0x13, 0x11],  # Z


}
from machine import Pin, I2C
import ssd1306

# Initialize I2C and SSD1306 OLED display (128x64 resolution)
i2c = I2C(0, scl=Pin(7), sda=Pin(6))
oled = ssd1306.SSD1306_I2C(128, 64, i2c)

def draw_char(oled, char, x, y):
    """Draw a single 5x7 character at position (x, y) on the OLED display."""
    if char in font5x7:
        char_data = font5x7[char]
        for col in range(5):  # Each character is 5 pixels wide
            byte = char_data[col]
            for row in range(7):  # Each character is 7 pixels tall
                # Draw pixel if the corresponding bit in the byte is set
                if byte & (1 << row):
                    oled.pixel(x + col, y + row, 1)

def display_all_characters(oled):
    """Display all characters from font5x7 on the 128x64 OLED display without overflowing the edges."""
    chars = sorted(list(font5x7.keys()))  # Get all the characters in sorted order
    char_index = 0  # Index to keep track of current character
    
    oled.fill(0)  # Clear the display
    x, y = 0, 0  # Start at the top-left corner
    
    # Loop through the rows and columns without overflowing
    for y in range(0, 64, 8):  # Increment by 8 for each row (7 pixels + 1 pixel spacing)
        for x in range(0, 128 - 6, 6):  # Increment by 6 for each column (5 pixels + 1 for spacing), stopping before the edge
            if char_index < len(chars):
                draw_char(oled, chars[char_index], x, y)  # Draw the current character
                char_index += 1  # Move to the next character
            else:
                break  # Stop if all characters have been printed
        if char_index >= len(chars):
            break  # Stop the outer loop as well if done
    
    oled.show()  # Update the display

from machine import Pin, I2C
import ssd1306

# Initialize I2C and SSD1306 OLED display (128x64 resolution)
i2c = I2C(0, scl=Pin(1), sda=Pin(0))
oled = ssd1306.SSD1306_I2C(128, 64, i2c)

def draw_char(oled, char, x, y, color=1):
    char = char.upper()
    """Draw a single 5x7 character at position (x, y) on the OLED display with the specified color."""
    if char in font5x7:
        char_data = font5x7[char]
        for col in range(5):  # Each character is 5 pixels wide
            byte = char_data[col]
            for row in range(7):  # Each character is 7 pixels tall
                # Draw pixel if the corresponding bit in the byte is set
                if byte & (1 << row):
                    oled.pixel(x + col, y + row, color)

def print_text(oled, text, x, y, color=1):
    """Draw a string of text on the OLED display starting at position (x, y) with the specified color."""
    for i, char in enumerate(text):
        draw_char(oled, char, x + i * 6, y, color)  # Move 6 pixels to the right for each character (5 for width + 1 for spacing)

# Example usage
oled.fill(0)  # Clear the display
print_text(oled, "Hello, World!", 0, 0, 1)  # Print "Hello, World!" at the top-left corner
oled.show()  # Update the display

# Display all characters
#display_all_characters(oled)


